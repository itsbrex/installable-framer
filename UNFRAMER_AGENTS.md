# Unframer-specific Guidelines

> **Editing instructions:** This file (`UNFRAMER_AGENTS.md`) is the source of truth for `AGENTS.md` in the unframer submodule. Edit this file, not `AGENTS.md` (generated) and not `CLAUDE.md` (deleted). Run `pnpm agents.md` from inside the `unframer/` directory to regenerate `AGENTS.md` after editing.

This project is a CLI called `unframer` that downloads Framer website builder components as React component files.

## Running the CLI locally

To run the unframer CLI locally during development, use the bin entry point (not cli.ts directly):

```bash
tsx unframer/src/bin.ts mcp login
tsx unframer/src/bin.ts --help
tsx unframer/src/bin.ts mcp getProjectXml
```

`src/cli.ts` only defines and exports the `cli` object. `src/bin.ts` imports it and calls `cli.parse()`.

## CRITICAL: Never edit framer.js manually

**NEVER edit `unframer/src/framer.js` directly!** This file is auto-generated by `scripts/download.ts`.

If you need to fix issues in framer.js:
1. Add string replacements to `fixFramerCode()` in `scripts/download.ts`
2. Run the download script with `download-framer:doppler` from root
3. The script will regenerate framer.js with your fixes applied

Example fix in download.ts:
```ts
codeAfter = codeAfter.replace(
    /const promise = import\(url\)\.then/g,
    'const promise = import(/* webpackIgnore: true */ /* @vite-ignore */ url).then',
)
```

## CRITICAL: Never create node_modules in unframer folder

**NEVER run `pnpm install` inside the unframer submodule folder!**

This submodule is part of the parent workspace at `unframer-private`. Dependencies must be installed from the root only:
```bash
cd /path/to/unframer-private
pnpm install
```

Having a separate `node_modules` in the unframer folder causes React duplication errors like:
- `TypeError: Cannot read properties of null (reading 'useContext')`
- Multiple React instances causing hooks to fail

If you see these errors, delete `unframer/node_modules` and reinstall from root.

## unframer mcp command — two modes

The `unframer mcp` CLI has two modes of operation, selected during `unframer mcp login` and saved in `~/.unframer/config.json`.

### Mode 1: Plugin mode (default, recommended)

Requires Framer to be open with the MCP plugin active in the browser.

```
AI Client (Claude/Cursor)
    │  StreamableHTTP
    ▼
mcp.unframer.co (Cloudflare Worker)
    │  WebSocket
    ▼
unframer.co/_tunnel (relay)
    │  WebSocket
    ▼
Framer Plugin (browser iframe, uses framer-plugin SDK)
```

**Setup:**
1. Open Framer project, press Cmd+K, search "MCP" plugin
2. Copy the URL shown in the plugin: `https://mcp.unframer.co/mcp?id={userId}&secret={token}`
3. Run `unframer mcp login <url>`

**How it works:**
- CLI connects to the remote MCP server at `mcp.unframer.co` via StreamableHTTP
- Worker opens a WebSocket to `unframer.co/_tunnel/client?id={userId}`
- Plugin is connected to `unframer.co/_tunnel/upstream?id={userId}`
- Tunnel relays tool calls between worker and plugin
- Plugin executes them via `framer-plugin` browser SDK
- **Scoped to the user** — same URL works across all projects
- Tool list is fetched from the remote server and cached for 1 hour

### Mode 2: Server API mode (headless, no browser)

Does not require Framer to be open. Uses `framer-api` npm package which runs **headless Chrome instances in the cloud** to interact with Framer. Expect an **initial delay of ~9 seconds** while the Chrome instance spins up on first connection.

```
CLI command
    │  direct function call
    ▼
mcpToolHandler() (in-process)
    │  framer-api SDK (headless Chrome in cloud)
    ▼
Framer Cloud
```

**Setup:**
1. Open Framer project settings → API → copy API key
2. Run `unframer mcp login` → select "Server API"
3. Enter API key and project URL

**How it works:**
- CLI dynamically imports `plugin-mcp-dist/lib/mcp-handlers.js` (pre-built copy of plugin-mcp handler code)
- Calls `framer-api.connect(projectUrl, apiKey)` which returns a `FramerClient`-compatible object
- Sets `globalThis.framer = framer` so the shared handler code can access it
- Tool calls happen **in-process** — no MCP server, no WebSocket, no HTTP
- The same `mcpToolHandler()` that runs in the browser plugin runs here in Node.js
- **Scoped to a specific project** (tied to API key + project URL)
- Pass `--project <url>` or set `FRAMER_PROJECT_URL` env var to switch projects

### Shared handler code

Both modes use the **exact same `mcpToolHandler()`** from `plugin-mcp/src/lib/mcp-handlers.ts`. The abstraction layer is the `FramerClient` interface, implemented by:
- `framer-plugin` — browser SDK (plugin mode)
- `framer-api` — Node.js SDK using headless Chrome in cloud (server-api mode)

### Keeping server-api mode up to date

The server-api mode uses pre-built JS from `unframer/src/plugin-mcp-dist/lib/`. This is generated by:

```bash
# Inside plugin-mcp/:
pnpm build       # tsc compiles to esm/lib/
pnpm gen-unframer # copies esm/lib/ → ../unframer/unframer/src/plugin-mcp-dist/lib/
```

The `pnpm pack` script in plugin-mcp automatically runs `build` + `gen-unframer` before creating the zip, so the unframer dist is always in sync when submitting for review.

If you change mcp-handlers.ts or schema.ts, always run `pnpm gen-unframer` inside plugin-mcp to update the unframer copy.

## Testing the framer exporting logic

To test changes in the framer exporting logic:
1. Run `pnpm --filter unframer build`
2. Then run `pnpm --filter nextjs-app framer-simplicity` to generate the framer components
3. Read the generated contents in `framer-simplicity/` to verify they are correct

Note: these components can be very large files.

## Logging

The unframer folder uses a logger. When using the `.debug()` method, logs are only visible when passing `--debug` to the unframer CLI:

```bash
pnpm --filter nextjs-app framer-simplicity --debug
```
